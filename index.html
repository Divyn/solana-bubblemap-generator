<!doctype html>
<meta charset="utf-8" />
<title>Solana Bubble Map</title>
<style>
  body { margin: 0; font-family: system-ui, sans-serif; }
  svg { width: 100vw; height: 100vh; background: #0b0f17; }
  .link { stroke: rgba(255,255,255,0.2); }
  .node { stroke: #111; stroke-width: 1px; }
  .label { fill: #ddd; font-size: 10px; pointer-events: none; }
  .legend { position: fixed; left: 12px; top: 12px; color: #ccc; }
  .legend b { color: #fff; }
  @media (prefers-contrast: more) { .link { stroke: rgba(255,255,255,0.4); } }
  .tooltip {
    position: fixed;
    z-index: 10;
    display: none;
    max-width: 320px;
    color: #e6edf3;
    background: rgba(13, 17, 23, 0.92);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px;
    box-shadow: 0 6px 24px rgba(0,0,0,0.35);
    padding: 10px 12px;
    font-size: 12px;
    line-height: 1.35;
    pointer-events: none;
    backdrop-filter: blur(4px);
  }
  .tooltip .title { font-weight: 600; margin-bottom: 4px; color: #fff; }
  .tooltip .row { display: flex; justify-content: space-between; gap: 12px; }
  .tooltip .muted { color: #9aa4b2; }
</style>
<div class="legend">Solana Bubble Map — <b>Size</b>: node USD volume, <b>Width</b>: link USD</div>
<svg></svg>
<div id="tooltip" class="tooltip"></div>
<script type="module">
import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';

const width = window.innerWidth;
const height = window.innerHeight;
const svg = d3.select('svg');

const data = await fetch('./bubblemap.json').then(r => r.json());
const nodes = data.nodes.map(d => ({ ...d }));
const links = data.links.map(d => ({ ...d }));

const valueExtent = d3.extent(nodes, d => d.value);
const r = d3.scaleSqrt().domain([Math.max(1, valueExtent[0] || 1), valueExtent[1] || 1]).range([3, 36]);
const w = d3.scaleSqrt().domain(d3.extent(links, d => d.value)).range([0.2, 6]);
const color = d3.scaleSequential(d3.interpolateTurbo).domain(d3.extent(nodes, d => d.value).reverse());
const fmtShort = d3.format(".3s");
const fmtFull = d3.format(",.2f");

const link = svg.append('g')
  .attr('stroke-linecap', 'round')
  .selectAll('line')
  .data(links)
  .join('line')
  .attr('class', 'link')
  .attr('stroke-width', d => w(d.value));

const node = svg.append('g')
  .selectAll('circle')
  .data(nodes)
  .join('circle')
  .attr('class', 'node')
  .attr('r', d => r(d.value))
  .attr('fill', d => color(d.value))
  .call(d3.drag()
    .on('start', (event, d) => { if (!event.active) sim.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
    .on('drag', (event, d) => { d.fx = event.x; d.fy = event.y; })
    .on('end', (event, d) => { if (!event.active) sim.alphaTarget(0); d.fx = null; d.fy = null; })
  );

// node.append('title')
//   .text(d => `${d.id}\n$${d3.format(",.2f")(d.value)}`);

// Build quick stats for tooltip
const inCount = new Map();
const outCount = new Map();
const totalLinkUsd = new Map();
for (const l of links) {
  outCount.set(l.source, (outCount.get(l.source) || 0) + 1);
  inCount.set(l.target, (inCount.get(l.target) || 0) + 1);
  totalLinkUsd.set(l.source, (totalLinkUsd.get(l.source) || 0) + (l.value || 0));
  totalLinkUsd.set(l.target, (totalLinkUsd.get(l.target) || 0) + (l.value || 0));
}

const tooltip = d3.select('#tooltip');
function positionTooltip(event) {
  const pad = 12;
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const tw = tooltip.node().offsetWidth || 240;
  const th = tooltip.node().offsetHeight || 100;
  let x = event.clientX + pad;
  let y = event.clientY + pad;
  if (x + tw + pad > vw) x = event.clientX - tw - pad;
  if (y + th + pad > vh) y = event.clientY - th - pad;
  tooltip.style('left', x + 'px').style('top', y + 'px');
}

node
  .on('mouseenter', (event, d) => {
    const incoming = inCount.get(d.id) || 0;
    const outgoing = outCount.get(d.id) || 0;
    const linkUsd = totalLinkUsd.get(d.id) || 0;
    tooltip
      .style('display', 'block')
      .html(
        `<div class="title">${d.label}</div>`+
        `<div class="row"><span class="muted">Node USD</span><span>$${fmtFull(d.value)}</span></div>`+
        `<div class="row"><span class="muted">Connected edges</span><span>${incoming + outgoing} (in ${incoming} / out ${outgoing})</span></div>`+
        `<div class="row"><span class="muted">Total linked USD</span><span>$${fmtShort(linkUsd)}</span></div>`
      );
    positionTooltip(event);
  })
  .on('mousemove', (event) => positionTooltip(event))
  .on('mouseleave', () => tooltip.style('display', 'none'));

// Show labels only for sufficiently large nodes to reduce clutter
// Set to always return false to hide all labels - use tooltips instead
const showLabel = d => false;
const label = svg.append('g')
  .selectAll('text')
  .data(nodes.filter(showLabel))
  .join('text')
  .attr('class', 'label')
  .attr('text-anchor', 'middle')
  .each(function(d) {
    const el = d3.select(this);
    // First line: short address
    el.append('tspan')
      .attr('x', 0)
      .attr('dy', 0)
      .text(d.label.slice(0, 4) + '…' + d.label.slice(-4));
    // Second line: compact USD amount
    el.append('tspan')
      .attr('x', 0)
      .attr('dy', 12)
      .text('$' + fmtShort(d.value));
  });

const sim = d3.forceSimulation(nodes)
  .force('link', d3.forceLink(links).id(d => d.id).distance(d => 40 + 2 * Math.sqrt(r(d.source?.value || 1) + r(d.target?.value || 1))))
  .force('charge', d3.forceManyBody().strength(-120))
  .force('collision', d3.forceCollide().radius(d => r(d.value) + 2))
  .force('center', d3.forceCenter(width / 2, height / 2))
  .on('tick', () => {
    link
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);
    node.attr('cx', d => d.x).attr('cy', d => d.y);
    label
      .attr('x', d => d.x)
      // place label just above the bubble
      .attr('y', d => d.y - r(d.value) - 6);
  });

window.addEventListener('resize', () => {
  const wv = window.innerWidth, hv = window.innerHeight;
  svg.attr('width', wv).attr('height', hv);
  sim.force('center', d3.forceCenter(wv / 2, hv / 2)).alpha(0.3).restart();
});
</script>


